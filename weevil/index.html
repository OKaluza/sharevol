<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title>sharevol/index.html at gh-pages · scmayo/sharevol</title>
  <meta name="Description" content="sharevol - Lightweight volume slicing and rendering in WebGL">
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1404.13">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 14.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 14.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
    span.s1 {font-kerning: none}
    span.Apple-tab-span {white-space:pre}
  </style>
</head>
<body>
<p class="p1"><span class="s1">&lt;!doctype html&gt;</span></p>
<p class="p1"><span class="s1">&lt;html&gt;</span></p>
<p class="p1"><span class="s1">&lt;head&gt;</span></p>
<p class="p1"><span class="s1">&lt;meta charset="UTF-8"&gt;</span></p>
<p class="p1"><span class="s1">&lt;meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=0" /&gt;</span></p>
<p class="p1"><span class="s1">&lt;title&gt;WebGL Volume Viewer - Sherry Mod&lt;/title&gt;</span></p>
<p class="p1"><span class="s1">&lt;script type="text/javascript" src="sharevol.js"&gt;&lt;/script&gt;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">&lt;script id="ray-fs" type="x-shader/x-fragment"&gt;</span></p>
<p class="p1"><span class="s1">/*</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space"> </span>* Copyright (c) 2014, Monash University. All rights reserved.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space"> </span>* Author: Owen Kaluza - owen.kaluza ( at ) monash.edu</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space"> </span>*</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space"> </span>* Licensed under the GNU Lesser General Public License</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space"> </span>* https://www.gnu.org/licenses/lgpl.html</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space"> </span>*Just added by Sherry</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space"> </span>*/</span></p>
<p class="p1"><span class="s1">precision highp float;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">//Defined dynamically before compile...</span></p>
<p class="p1"><span class="s1">//const vec2 slices = vec2(16.0,16.0);</span></p>
<p class="p1"><span class="s1">//const int maxSamples = 256;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">uniform sampler2D uVolume;</span></p>
<p class="p1"><span class="s1">uniform sampler2D uTransferFunction;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">uniform vec3 uBBMin;</span></p>
<p class="p1"><span class="s1">uniform vec3 uBBMax;</span></p>
<p class="p1"><span class="s1">uniform vec3 uResolution;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">uniform bool uEnableColour;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">uniform float uBrightness;</span></p>
<p class="p1"><span class="s1">uniform float uContrast;</span></p>
<p class="p1"><span class="s1">uniform float uPower;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">uniform mat4 uMVMatrix;</span></p>
<p class="p1"><span class="s1">uniform mat4 uNMatrix;</span></p>
<p class="p1"><span class="s1">uniform float uFocalLength;</span></p>
<p class="p1"><span class="s1">uniform vec2 uWindowSize;</span></p>
<p class="p1"><span class="s1">uniform int uSamples;</span></p>
<p class="p1"><span class="s1">uniform float uDensityFactor;</span></p>
<p class="p1"><span class="s1">uniform float uIsoValue;</span></p>
<p class="p1"><span class="s1">uniform vec4 uIsoColour;</span></p>
<p class="p1"><span class="s1">uniform float uIsoSmooth;</span></p>
<p class="p1"><span class="s1">uniform int uIsoWalls;</span></p>
<p class="p1"><span class="s1">uniform int uFilter;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">//#define tex3D(pos) interpolate_tricubic_fast(pos)</span></p>
<p class="p1"><span class="s1">//#define tex3D(pos) texture3Dfrom2D(pos).x</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">vec2 islices = vec2(1.0 / slices.x, 1.0 / slices.y);</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">vec4 texture3Dfrom2D(vec3 pos)</span></p>
<p class="p1"><span class="s1">{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>//Get z slice index and position between two slices</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>float Z = pos.z * slices.x * slices.y;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>int slice = int(Z); //Index of first slice</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>//X &amp; Y coords of sample scaled to slice size</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec2 sampleOffset = pos.xy * islices;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>//Offsets in 2D texture of given slice indices</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>//(add offsets to scaled position within slice to get sample positions)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>float A = float(slice) * islices.x;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>float B = float(slice+1) * islices.x;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec2 z1offset = vec2(fract(A), floor(A) / slices.y) + sampleOffset;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec2 z2offset = vec2(fract(B), floor(B) / slices.y) + sampleOffset;</span></p>
<p class="p2"><span class="s1"><span class="Apple-converted-space">  </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>//Interpolate the final value by position between slices [0,1]</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>return mix(texture2D(uVolume, z1offset), texture2D(uVolume, z2offset), fract(Z));</span></p>
<p class="p1"><span class="s1">}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">float interpolate_tricubic_fast(vec3 coord);</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">float tex3D(vec3 pos)<span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1">{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>if (uFilter &gt; 0)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>return interpolate_tricubic_fast(pos);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>return texture3Dfrom2D(pos).x;</span></p>
<p class="p1"><span class="s1">}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">// It seems WebGL has no transpose</span></p>
<p class="p1"><span class="s1">mat4 transpose(in mat4 m)</span></p>
<p class="p1"><span class="s1">{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>return mat4(</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">              </span>vec4(m[0].x, m[1].x, m[2].x, m[3].x),</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">              </span>vec4(m[0].y, m[1].y, m[2].y, m[3].y),</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">              </span>vec4(m[0].z, m[1].z, m[2].z, m[3].z),</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">              </span>vec4(m[0].w, m[1].w, m[2].w, m[3].w)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">             </span>);</span></p>
<p class="p1"><span class="s1">}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">//Light moves with camera</span></p>
<p class="p1"><span class="s1">const vec3 lightPos = vec3(0.5, 0.5, 5.0);</span></p>
<p class="p1"><span class="s1">const float ambient = 0.2;</span></p>
<p class="p1"><span class="s1">const float diffuse = 0.8;</span></p>
<p class="p1"><span class="s1">const vec3 diffColour = vec3(1.0, 1.0, 1.0);<span class="Apple-converted-space">  </span>//Colour of diffuse light</span></p>
<p class="p1"><span class="s1">const vec3 ambColour = vec3(0.2, 0.2, 0.2); <span class="Apple-converted-space">  </span>//Colour of ambient light</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">void lighting(in vec3 pos, in vec3 normal, inout vec3 colour)</span></p>
<p class="p1"><span class="s1">{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec4 vertPos = uMVMatrix * vec4(pos, 1.0);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 lightDir = normalize(lightPos - vertPos.xyz);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 lightWeighting = ambColour + diffColour * diffuse * clamp(abs(dot(normal, lightDir)), 0.1, 1.0);</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>colour *= lightWeighting;</span></p>
<p class="p1"><span class="s1">}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">vec3 isoNormal(in vec3 pos, in vec3 shift, in float density)</span></p>
<p class="p1"><span class="s1">{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 shiftpos = vec3(pos.x + shift.x, pos.y + shift.y, pos.z + shift.z);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 shiftx = vec3(shiftpos.x, pos.y, pos.z);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 shifty = vec3(pos.x, shiftpos.y, pos.z);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 shiftz = vec3(pos.x, pos.y, shiftpos.z);</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>//Detect bounding box hit (walls)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>if (uIsoWalls &gt; 0)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>if (pos.x &lt;= uBBMin.x) return vec3(-1.0, 0.0, 0.0);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>if (pos.x &gt;= uBBMax.x) return vec3(1.0, 0.0, 0.0);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>if (pos.y &lt;= uBBMin.y) return vec3(0.0, -1.0, 0.0);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>if (pos.y &gt;= uBBMax.y) return vec3(0.0, 1.0, 0.0);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>if (pos.z &lt;= uBBMin.z) return vec3(0.0, 0.0, -1.0);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>if (pos.z &gt;= uBBMax.z) return vec3(0.0, 0.0, 1.0);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>//Calculate normal</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>return vec3(density) - vec3(tex3D(shiftx), tex3D(shifty), tex3D(shiftz));</span></p>
<p class="p1"><span class="s1">}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">vec2 rayIntersectBox(vec3 rayDirection, vec3 rayOrigin)</span></p>
<p class="p1"><span class="s1">{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>//Intersect ray with bounding box</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 rayInvDirection = 1.0 / rayDirection;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 bbMinDiff = (uBBMin - rayOrigin) * rayInvDirection;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 bbMaxDiff = (uBBMax - rayOrigin) * rayInvDirection;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 imax = max(bbMaxDiff, bbMinDiff);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 imin = min(bbMaxDiff, bbMinDiff);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>float back = min(imax.x, min(imax.y, imax.z));</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>float front = max(max(imin.x, 0.0), max(imin.y, imin.z));</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>return vec2(back, front);</span></p>
<p class="p1"><span class="s1">}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">void main()</span></p>
<p class="p1"><span class="s1">{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>//Correct gl_FragCoord for aspect ratio</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>float aspect = uWindowSize.x / uWindowSize.y;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>vec2 coord = vec2((gl_FragCoord.x - (uWindowSize.x - uWindowSize.y) * 0.5) * aspect, gl_FragCoord.y);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>vec3 rayDirection = normalize((vec4(2.0 * coord / uWindowSize - 1.0, -uFocalLength, 0) * uMVMatrix).xyz);</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>vec4 camPos = -vec4(uMVMatrix[3]);<span class="Apple-converted-space">  </span>//4th column of modelview</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>vec3 rayOrigin = (transpose(uMVMatrix) * camPos).xyz;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>//Calc step</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>float stepSize = 1.732 / float(uSamples); //diagonal of [0,1] normalised coord cube = sqrt(3)</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>//Intersect ray with bounding box</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>vec2 intersection = rayIntersectBox(rayDirection, rayOrigin);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>//Subtract small increment to avoid errors on front boundary</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>intersection.y -= 0.000001;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>//Discard points outside the box (no intersection)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>if (intersection.x &lt;= intersection.y) discard;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>vec3 rayStart = rayOrigin + rayDirection * intersection.y;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>vec3 rayStop = rayOrigin + rayDirection * intersection.x;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>vec3 step = normalize(rayStop-rayStart) * stepSize;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>vec3 pos = rayStart;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>float T = 1.0;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>vec3 colour = vec3(0.0);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>bool inside = false;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>vec3 shift = uIsoSmooth / uResolution;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>//Number of samples to take along this ray before we pass out back of volume...</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>float travel = distance(rayStop, rayStart) / stepSize;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>int samples = int(ceil(travel));</span></p>
<p class="p2"><span class="s1"><span class="Apple-converted-space">  </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>//Raymarch, front to back</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>for (int i=0; i &lt; maxSamples; ++i)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">      </span>//Render samples until we pass out back of cube or fully opaque</span></p>
<p class="p1"><span class="s1">#ifndef IE11</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">      </span>if (i == samples || T &lt; 0.01) break;</span></p>
<p class="p1"><span class="s1">#else</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">      </span>//This is slower but allows IE 11 to render, break on non-uniform condition causes it to fail</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">      </span>if (i == uSamples) break;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">      </span>if (all(greaterThanEqual(pos, uBBMin)) &amp;&amp; all(lessThanEqual(pos, uBBMax)))</span></p>
<p class="p1"><span class="s1">#endif</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">      </span>{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>//Get density<span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>float density = tex3D(pos);</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">#define ISOSURFACE</span></p>
<p class="p1"><span class="s1">#ifdef ISOSURFACE</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>//Passed through isosurface?</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>if (uIsoValue &gt; 0.0 &amp;&amp; ((!inside &amp;&amp; density &gt;= uIsoValue) || (inside &amp;&amp; density &lt; uIsoValue)))</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>inside = !inside;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>//Find closer to exact position by iteration</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>//http://sizecoding.blogspot.com.au/2008/08/isosurfaces-in-glsl.html</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>float exact;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>float a = intersection.y + (float(i)*stepSize);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>float b = a - stepSize;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>for(int i = 0; i &lt; 5; i++)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>exact = (b + a) * 0.5;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>pos = rayDirection * exact + rayOrigin;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>density = tex3D(pos);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>if (density - uIsoValue &lt; 0.0)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">              </span>b = exact;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>else</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">              </span>a = exact;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>//Skip edges unless flagged to draw</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>if (uIsoWalls &gt; 0 || all(greaterThanEqual(pos, uBBMin)) &amp;&amp; all(lessThanEqual(pos, uBBMax)))</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>vec4 value = vec4(uIsoColour.rgb, 1.0);</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>//normal = normalize(normal);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>//if (length(normal) &lt; 1.0) normal = vec3(0.0, 1.0, 0.0);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>vec3 normal = normalize(mat3(uNMatrix) * isoNormal(pos, shift, density));</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>vec3 light = value.rgb;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>lighting(pos, normal, light);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>//Front-to-back blend equation</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>colour += T * uIsoColour.a * light;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>T *= (1.0 - uIsoColour.a);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p1"><span class="s1">#endif</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>if (uDensityFactor &gt; 0.0)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>density = pow(density, uPower); //Apply power</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>vec4 value;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>if (uEnableColour)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>value = texture2D(uTransferFunction, vec2(density, 0.5));</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>else</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>value = vec4(density);</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>value *= uDensityFactor * stepSize;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>//Color</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>colour += T * value.rgb;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>//Alpha</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">          </span>T *= 1.0 - value.a;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">      </span>}</span></p>
<p class="p2"><span class="s1"><span class="Apple-tab-span">	</span> <span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">      </span>//Next sample...</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">      </span>pos += step;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>//Apply brightness &amp; contrast</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>colour = ((colour - 0.5) * max(uContrast, 0.0)) + 0.5;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>colour += uBrightness;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>gl_FragColor = vec4(colour, 1.0 - T);</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">#ifdef WRITE_DEPTH</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>/* Write the depth !Not supported in WebGL without extension */</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>if (writeDepth)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">      </span>vec4 clip_space_pos = uPMatrix * pos;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">      </span>float ndc_depth = clip_space_pos.z / clip_space_pos.w;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">      </span>float depth = (((gl_DepthRange.far - gl_DepthRange.near) * ndc_depth) +<span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                     </span>gl_DepthRange.near + gl_DepthRange.far) / 2.0;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">      </span>gl_FragDepth = depth;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>else</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">      </span>gl_FragDepth = gl_DepthRange.far;</span></p>
<p class="p1"><span class="s1">#endif</span></p>
<p class="p1"><span class="s1">}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">float interpolate_tricubic_fast(vec3 coord)</span></p>
<p class="p1"><span class="s1">{</span></p>
<p class="p1"><span class="s1">/* License applicable to this function:</span></p>
<p class="p1"><span class="s1">Copyright (c) 2008-2013, Danny Ruijters. All rights reserved.</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">Redistribution and use in source and binary forms, with or without</span></p>
<p class="p1"><span class="s1">modification, are permitted provided that the following conditions are met:</span></p>
<p class="p1"><span class="s1">*<span class="Apple-converted-space">  </span>Redistributions of source code must retain the above copyright</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">   </span>notice, this list of conditions and the following disclaimer.</span></p>
<p class="p1"><span class="s1">*<span class="Apple-converted-space">  </span>Redistributions in binary form must reproduce the above copyright</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">   </span>notice, this list of conditions and the following disclaimer in the</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">   </span>documentation and/or other materials provided with the distribution.</span></p>
<p class="p1"><span class="s1">*<span class="Apple-converted-space">  </span>Neither the name of the copyright holders nor the names of its</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">   </span>contributors may be used to endorse or promote products derived from</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">   </span>this software without specific prior written permission.</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"</span></p>
<p class="p1"><span class="s1">AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span></p>
<p class="p1"><span class="s1">IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span></p>
<p class="p1"><span class="s1">ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</span></p>
<p class="p1"><span class="s1">LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span></p>
<p class="p1"><span class="s1">CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span></p>
<p class="p1"><span class="s1">SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span></p>
<p class="p1"><span class="s1">INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span></p>
<p class="p1"><span class="s1">CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span></p>
<p class="p1"><span class="s1">ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span></p>
<p class="p1"><span class="s1">POSSIBILITY OF SUCH DAMAGE.</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">The views and conclusions contained in the software and documentation are</span></p>
<p class="p1"><span class="s1">those of the authors and should not be interpreted as representing official</span></p>
<p class="p1"><span class="s1">policies, either expressed or implied.</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">When using this code in a scientific project, please cite one or all of the</span></p>
<p class="p1"><span class="s1">following papers:</span></p>
<p class="p1"><span class="s1">*<span class="Apple-converted-space">  </span>Daniel Ruijters and Philippe Thévenaz,</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">   </span>GPU Prefilter for Accurate Cubic B-Spline Interpolation,<span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">   </span>The Computer Journal, vol. 55, no. 1, pp. 15-20, January 2012.</span></p>
<p class="p1"><span class="s1">*<span class="Apple-converted-space">  </span>Daniel Ruijters, Bart M. ter Haar Romeny, and Paul Suetens,</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">   </span>Efficient GPU-Based Texture Interpolation using Uniform B-Splines,</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">   </span>Journal of Graphics Tools, vol. 13, no. 4, pp. 61-69, 2008.</span></p>
<p class="p1"><span class="s1">*/</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>// shift the coordinate from [0,1] to [-0.5, nrOfVoxels-0.5]</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 nrOfVoxels = uResolution; //textureSize3D(tex, 0));</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 coord_grid = coord * nrOfVoxels - 0.5;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 index = floor(coord_grid);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 fraction = coord_grid - index;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 one_frac = 1.0 - fraction;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 w0 = 1.0/6.0 * one_frac*one_frac*one_frac;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 w1 = 2.0/3.0 - 0.5 * fraction*fraction*(2.0-fraction);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 w2 = 2.0/3.0 - 0.5 * one_frac*one_frac*(2.0-one_frac);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 w3 = 1.0/6.0 * fraction*fraction*fraction;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 g0 = w0 + w1;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 g1 = w2 + w3;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 mult = 1.0 / nrOfVoxels;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 h0 = mult * ((w1 / g0) - 0.5 + index);<span class="Apple-converted-space">  </span>//h0 = w1/g0 - 1, move from [-0.5, nrOfVoxels-0.5] to [0,1]</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec3 h1 = mult * ((w3 / g1) + 1.5 + index);<span class="Apple-converted-space">  </span>//h1 = w3/g1 + 1, move from [-0.5, nrOfVoxels-0.5] to [0,1]</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>// fetch the eight linear interpolations</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>// weighting and fetching is interleaved for performance and stability reasons</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>float tex000 = texture3Dfrom2D(h0).r;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>float tex100 = texture3Dfrom2D(vec3(h1.x, h0.y, h0.z)).r;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>tex000 = mix(tex100, tex000, g0.x);<span class="Apple-converted-space">  </span>//weigh along the x-direction</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>float tex010 = texture3Dfrom2D(vec3(h0.x, h1.y, h0.z)).r;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>float tex110 = texture3Dfrom2D(vec3(h1.x, h1.y, h0.z)).r;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>tex010 = mix(tex110, tex010, g0.x);<span class="Apple-converted-space">  </span>//weigh along the x-direction</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>tex000 = mix(tex010, tex000, g0.y);<span class="Apple-converted-space">  </span>//weigh along the y-direction</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>float tex001 = texture3Dfrom2D(vec3(h0.x, h0.y, h1.z)).r;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>float tex101 = texture3Dfrom2D(vec3(h1.x, h0.y, h1.z)).r;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>tex001 = mix(tex101, tex001, g0.x);<span class="Apple-converted-space">  </span>//weigh along the x-direction</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>float tex011 = texture3Dfrom2D(vec3(h0.x, h1.y, h1.z)).r;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>float tex111 = texture3Dfrom2D(h1).r;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>tex011 = mix(tex111, tex011, g0.x);<span class="Apple-converted-space">  </span>//weigh along the x-direction</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>tex001 = mix(tex011, tex001, g0.y);<span class="Apple-converted-space">  </span>//weigh along the y-direction</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>return mix(tex001, tex000, g0.z);<span class="Apple-converted-space">  </span>//weigh along the z-direction</span></p>
<p class="p1"><span class="s1">}</span></p>
<p class="p1"><span class="s1">&lt;/script&gt;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">&lt;script id="ray-vs" type="x-shader/x-vertex"&gt;</span></p>
<p class="p1"><span class="s1">precision highp float;</span></p>
<p class="p1"><span class="s1">attribute vec3 aVertexPosition;</span></p>
<p class="p1"><span class="s1">void main(void)</span></p>
<p class="p1"><span class="s1">{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>gl_Position = vec4(aVertexPosition, 1.0);</span></p>
<p class="p1"><span class="s1">}</span></p>
<p class="p1"><span class="s1">&lt;/script&gt;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">&lt;script id="texture-fs" type="x-shader/x-fragment"&gt;</span></p>
<p class="p1"><span class="s1">//Texture fragment shader</span></p>
<p class="p1"><span class="s1">precision mediump float;</span></p>
<p class="p1"><span class="s1">#define rgba vec4</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">//Palette lookup mu = [0,1]</span></p>
<p class="p1"><span class="s1">#define gradient(mu) texture2D(palette, vec2(mu, 0.0))</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">//Uniform data</span></p>
<p class="p1"><span class="s1">uniform sampler2D palette;</span></p>
<p class="p1"><span class="s1">uniform sampler2D texture;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">uniform int colourmap;</span></p>
<p class="p1"><span class="s1">uniform float bright;</span></p>
<p class="p1"><span class="s1">uniform float cont;</span></p>
<p class="p1"><span class="s1">uniform float power;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">uniform int axis;</span></p>
<p class="p1"><span class="s1">uniform vec3 slice;</span></p>
<p class="p1"><span class="s1">uniform ivec3 res;</span></p>
<p class="p1"><span class="s1">uniform vec2 dim;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">uniform ivec2 select;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">//Current coordinate</span></p>
<p class="p1"><span class="s1">varying vec2 vCoord;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">void main()</span></p>
<p class="p1"><span class="s1">{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>bool invert = false;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec2 coord;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>float z;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>if (int(gl_FragCoord.x) == select.x) invert = true;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>if (int(gl_FragCoord.y) == select.y) invert = true;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>if (axis==0)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>//x-axis slice</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>//slice offset coords from vCoord.x, inside coords from (slice,vCoord.y)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>z = vCoord.x * float(res.z);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>coord = vec2(clamp(slice.x, 0.0, 0.999), vCoord.y);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>else if (axis==1)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>//y-axis slice</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>//slice offset coords from vCoord.y, inside coords from (vCoord.x,slice)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>z = vCoord.y * float(res.z);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>coord = vec2(vCoord.x, clamp(slice.y, 0.0, 0.999));</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>else if (axis==2)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>//z-axis slice</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>//slice offset coords from slice.z, inside coords unchanged (vCoord.xy)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>z = slice.z * float(res.z);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>coord = vCoord;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>//Get offsets to selected slice</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>float xy = z/dim.x;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>int row = int(xy);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>//mod() function doesn't work properly on safari, use fract() instead</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>//int col = int(fract(xy) * dim.x);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>int col = int(fract(xy) * dim.x);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>coord += vec2(float(col), float(row));</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>//Rescale to texture coords [0,1]</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>coord /= dim;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>//Get texture value at coord and calculate final colour</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec4 tex = texture2D(texture, coord);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>float lum = tex.r; //0.3 * tex.r + 0.59 * tex.g + 0.11 * tex.b;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>lum = pow(lum, power);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec4 pixelColor;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>if (colourmap == 1)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>pixelColor = gradient(lum);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>else</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>pixelColor = vec4(lum, lum, lum, 1.0);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>pixelColor.rgb = ((pixelColor.rgb - 0.5) * max(cont, 0.0)) + 0.5;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>pixelColor.rgb += bright;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>if (invert)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>pixelColor.rgb = vec3(1.0) - pixelColor.rgb;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>pixelColor.a = 1.0;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>gl_FragColor = pixelColor;</span></p>
<p class="p1"><span class="s1">}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">&lt;/script&gt;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">&lt;script id="texture-vs" type="x-shader/x-vertex"&gt;</span></p>
<p class="p1"><span class="s1">//A simple vertex shader for 2d image processing</span></p>
<p class="p1"><span class="s1">//Pass the vertex coords to fragment shader in vCoord</span></p>
<p class="p1"><span class="s1">precision highp float;</span></p>
<p class="p1"><span class="s1">attribute vec3 aVertexPosition;</span></p>
<p class="p1"><span class="s1">uniform mat4 uMVMatrix;</span></p>
<p class="p1"><span class="s1">varying vec2 vCoord;</span></p>
<p class="p1"><span class="s1">void main(void) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>gl_Position = vec4(aVertexPosition, 1.0);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>//Apply translation, rotation &amp; scaling matrix to vertices to get coords</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec4 coords = uMVMatrix * vec4(aVertexPosition.xy, 0.0, 1.0);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vCoord = coords.xy;</span></p>
<p class="p1"><span class="s1">}</span></p>
<p class="p1"><span class="s1">&lt;/script&gt;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">&lt;script id="line-fs" type="x-shader/x-fragment"&gt;</span></p>
<p class="p1"><span class="s1">precision highp float;</span></p>
<p class="p1"><span class="s1">varying vec4 vColour;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">void main(void)</span></p>
<p class="p1"><span class="s1">{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>gl_FragColor = vColour;</span></p>
<p class="p1"><span class="s1">}</span></p>
<p class="p1"><span class="s1">&lt;/script&gt;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">&lt;script id="line-vs" type="x-shader/x-vertex"&gt;</span></p>
<p class="p1"><span class="s1">precision highp float;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">attribute vec3 aVertexPosition;</span></p>
<p class="p1"><span class="s1">attribute vec4 aVertexColour;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">uniform mat4 uMVMatrix;</span></p>
<p class="p1"><span class="s1">uniform mat4 uPMatrix;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">uniform vec4 uColour;</span></p>
<p class="p1"><span class="s1">uniform float uAlpha;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">varying vec4 vColour;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">void main(void)</span></p>
<p class="p1"><span class="s1">{</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec4 mvPosition = uMVMatrix * vec4(aVertexPosition, 1.0);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>gl_Position = uPMatrix * mvPosition;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vec4 colour = aVertexColour;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>float alpha = 1.0;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>if (uColour.a &gt; 0.01) colour = uColour;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>if (uAlpha &gt; 0.01) alpha = uAlpha;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>vColour = vec4(colour.rgb, colour.a * alpha);</span></p>
<p class="p1"><span class="s1">}</span></p>
<p class="p1"><span class="s1">&lt;/script&gt;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">&lt;style&gt;</span></p>
<p class="p1"><span class="s1">html {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>font-family: "Lucida Grande",sans-serif;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>font-size: 11pt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>background: #ffe;</span></p>
<p class="p1"><span class="s1">}</span></p>
<p class="p1"><span class="s1">html, body {<span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>padding: 0; margin: 0;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>border: none;<span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>width: 100%;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>height: 100%;</span></p>
<p class="p1"><span class="s1">}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">.palette {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>z-index: 0; margin: 0; padding:0;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>border:1px solid #000;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>border-radius: 4px;</span></p>
<p class="p1"><span class="s1">}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">.checkerboard {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAIElEQVQ4jWP4TwAcOHAAL2YYNWBYGEBIASEwasCwMAAALvidroqDalkAAAAASUVORK5CYII=");}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">/* Background colour */</span></p>
<p class="p1"><span class="s1">#backgroundBG { float: left; margin: 0px 2px 0px 0px; width: 24px; height: 24px;}</span></p>
<p class="p1"><span class="s1">#backgroundCUR { float: left; width: 24px; height: 24px;}</span></p>
<p class="p1"><span class="s1">/* Colour select */</span></p>
<p class="p1"><span class="s1">.colourbg { margin:1px; width: 100px; height: 20px; border: solid 1px; border-radius: 4px;}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">.toolbox {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>visibility: hidden; z-index: 20;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>background: rgba(255,255,255,0.5);<span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>color: #000;<span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>cursor: move;<span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>padding: 7px 10px 11px 10px;<span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>position: absolute;<span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>border-radius: 5px; border: 1px solid #444;<span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>min-width: 300px;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>max-height: 400px;</span></p>
<p class="p1"><span class="s1">}</span></p>
<p class="p1"><span class="s1">.scroll {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>overflow-y: auto;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>max-height: 330px;</span></p>
<p class="p1"><span class="s1">}</span></p>
<p class="p1"><span class="s1">.toolbox div,table,td,tr {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>cursor: move;<span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1">}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">.toolbox * {cursor: auto;}</span></p>
<p class="p1"><span class="s1">.toolbox form {cursor: move;}</span></p>
<p class="p1"><span class="s1">.toolbox form * {cursor: auto;}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">.toolclose {float: right; cursor: pointer; color: #333; margin: 0px; font-weight: bold;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>border: none; padding: 0px 4px; font-size: 14pt; line-height: 16px;}</span></p>
<p class="p1"><span class="s1">.toolbox h3 {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>font-size: 10pt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>font-weight: bold;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>margin: 2px 0px; padding: 0;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>display: inline;</span></p>
<p class="p1"><span class="s1">}</span></p>
<p class="p1"><span class="s1">&lt;/style&gt;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">&lt;/head&gt;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">&lt;body onload="initPage();" oncontextmenu="return false;"&gt;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">&lt;div id="hidden" style="display: none"&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>&lt;canvas id="gradient" width="2048" height="1"&gt;&lt;/canvas&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>&lt;input name="file" id="fileupload" type="file" onchange="fileSelected(this.files)" &gt;</span></p>
<p class="p1"><span class="s1">&lt;/div&gt;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">&lt;div class="toolbox" id="info"&gt;&lt;div&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>&lt;h3 id="status"&gt;Loading...&lt;/h3&gt;</span></p>
<p class="p1"><span class="s1">&lt;/div&gt;&lt;/div&gt;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">&lt;div class="toolbox" id="colourmap"&gt;&lt;div&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>&lt;div class="toolclose" onclick="window.colourmaps.hide();"&gt;&amp;times;&lt;/div&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>&lt;h3&gt;Colourmaps:&lt;/h3&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>&lt;hr&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>&lt;select id="colourmaps" onchange="setColourMap(this.value);"&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>&lt;option value="" selected&gt;None&lt;/option&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>&lt;option value="Default.cmap"&gt;Default&lt;/option&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>&lt;option value="CoolWarm.cmap"&gt;Cool-Warm&lt;/option&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>&lt;option value="HOTIRON.cmap"&gt;Hot iron&lt;/option&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>&lt;option value="NIH.cmap"&gt;NIH&lt;/option&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>&lt;option value="spectrum.cmap"&gt;Spectrum&lt;/option&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>&lt;/select&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>&lt;br&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>&lt;canvas id="palette" width="512" height="24" class="palette checkerboard"&gt;&lt;/canvas&gt;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>&lt;div id="backgroundBG" class="colourbg checkerboard"&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>&lt;div id="backgroundCUR" class="colour" onmousedown="colours.editBackground($('backgroundCUR'));"&gt;&lt;/div&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>&lt;/div&gt;Background</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">&lt;/div&gt;&lt;/div&gt;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">&lt;/body&gt;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">&lt;/html&gt;</span></p>
</body>
</html>
